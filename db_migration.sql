/* This file is "idempotent" - running it multiple times will not put the DB in an incorrect state */

CREATE DATABASE apartment_finder;
\c apartment_finder

-- turn off NOTICE
SET client_min_messages TO WARNING;

-- make sure we can create UUID primary keys
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-- Postgis
CREATE EXTENSION IF NOT EXISTS "postgis";

CREATE TABLE IF NOT EXISTS map_features (
    map_feature_id uuid DEFAULT uuid_generate_v4(),
    map_feature_label TEXT,
    map_feature_type TEXT,
    geojson jsonb,  -- generated by a trigger, stores pre-computed geojson
    map_feature_label_parts TEXT[], -- generated by a trigger
     PRIMARY KEY (map_feature_id)
);
SELECT AddGeometryColumn('map_features','geom','4326','GEOMETRY',2);
CREATE INDEX IF NOT EXISTS map_features_geom_idx ON map_features USING GIST (geom);
CREATE INDEX IF NOT EXISTS map_features_label_parts_idx ON map_features USING GIN (map_feature_label_parts);

/*  A trigger to keep our GeoJSON updated. 
    Why update this with a trigger rather than just computing it on the fly using 'ST_asGeoJson'?
    Because a specific feature will SELECTed as part of a search (requiring its geojson) 
    far more often that it will be UPDATEd (we're trading space for time).
    
    In Postgres 12, these triggers are no longer needed. The geojson column would be defined in the table above as:
    `geojson jsonb GENERATED ALWAYS AS (ST_asGeoJson(geom, 6, 0)::jsonb) STORED`;
    */ 
CREATE OR REPLACE FUNCTION update_map_feature_geojson() RETURNS trigger AS $$
    DECLARE
        v_geojson jsonb;
    BEGIN 
        SELECT ST_asGeoJson(NEW.geom, 6, 0)::jsonb INTO v_geojson ;
        NEW.geojson := v_geojson;
        RETURN NEW;
    END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_map_feature_geojson_but ON map_features;

CREATE TRIGGER update_map_feature_geojson_but BEFORE UPDATE
OF geom ON map_features FOR EACH ROW 
WHEN (NEW.geom IS DISTINCT FROM OLD.geom) 
EXECUTE PROCEDURE update_map_feature_geojson();

DROP TRIGGER IF EXISTS update_map_feature_geojson_bit ON map_features;

CREATE TRIGGER update_map_feature_geojson_bit 
BEFORE INSERT ON map_features FOR EACH ROW 
EXECUTE PROCEDURE update_map_feature_geojson();

-- a trigger to keep our label_parts updated. we want the label split for indexed searches 
CREATE OR REPLACE FUNCTION update_map_feature_label_parts() RETURNS trigger AS $$
    DECLARE
        v_label_parts TEXT[];
    BEGIN 
        SELECT ARRAY(SELECT TRIM(both FROM unnest(string_to_array(NEW.map_feature_label, ','))))
        INTO v_label_parts;
        NEW.map_feature_label_parts := v_label_parts;
        RETURN NEW;
    END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_map_feature_label_parts_but ON map_features;
CREATE TRIGGER update_map_feature_label_parts_but BEFORE UPDATE
OF map_feature_label ON map_features FOR EACH ROW 
WHEN (NEW.map_feature_label IS DISTINCT FROM OLD.map_feature_label) -- only run the trigger if this column has changed
EXECUTE PROCEDURE update_map_feature_label_parts();

DROP TRIGGER IF EXISTS update_map_feature_label_parts_bit ON map_features;
CREATE TRIGGER update_map_feature_label_parts_bit 
BEFORE INSERT ON map_features FOR EACH ROW 
EXECUTE PROCEDURE update_map_feature_label_parts();

/*  Get all the geometries that intersect a point, or that intersect any features that *those* features intersect. 
    Essentially, this constructs an entire tree for an area on the fly based on intersecting geometries. */
DROP FUNCTION IF EXISTS features_intersecting(DOUBLE PRECISION, DOUBLE PRECISION);
CREATE OR REPLACE FUNCTION features_intersecting(lng DOUBLE PRECISION, lat DOUBLE PRECISION) RETURNS uuid[] AS $$
        SELECT ARRAY(WITH RECURSIVE tree AS (
            SELECT map_feature_id, geom  
                FROM map_features
                WHERE st_intersects(geom, ST_SetSRID(ST_MakePoint(lng, lat), 4326))
            UNION
                SELECT mf.map_feature_id, mf.geom
                FROM map_features mf, tree
                WHERE st_intersects(tree.geom, mf.geom)
            )
            SELECT map_feature_id::uuid FROM tree);
$$ LANGUAGE sql STABLE PARALLEL SAFE;

/*  The geojson is expected to be a 'Feature', in the form: 
    {"type":"Feature",
    "geometry":{"type":"Polygon","coordinates":[[[-93.4479674953537,45.10671008927187],[-93.44764026585388,45.10639773144287],[-93.44852003041076,45.10614405776647],[-93.44863804760742,45.10652078170077],[-93.44832691136169,45.10660975633737],[-93.4479674953537,45.10671008927187]]]},
    "properties":{"id":"b14416f5-4077-4dfc-b5c3-34a6d863a3b1","type":"Building","label":"Hi mom!"},
    "id":"b14416f5-4077-4dfc-b5c3-34a6d863a3b1"} */
DROP FUNCTION IF EXISTS upsert_map_feature(jsonb);
CREATE OR REPLACE FUNCTION upsert_map_feature(geojson jsonb) RETURNS jsonb AS $$
    DECLARE 
        v_id uuid;
        v_geom geometry(Geometry,4326);
        v_label TEXT;
        v_feature_type TEXT;
    BEGIN
        v_id := (upsert_map_feature.geojson->>'id')::uuid;
        v_geom := ST_SetSRID(ST_GeomFromGeoJSON(upsert_map_feature.geojson->>'geometry'), 4326);
        v_label := (upsert_map_feature.geojson#>>'{properties, label}')::TEXT;
        v_feature_type := (upsert_map_feature.geojson#>>'{properties, type}')::TEXT;

        INSERT INTO map_features (map_feature_id, geom, map_feature_label, map_feature_type)
        VALUES (v_id, v_geom, v_label, v_feature_type)
        ON CONFLICT (map_feature_id) 
        DO UPDATE SET geom = EXCLUDED.geom, map_feature_label = EXCLUDED.map_feature_label, 
                map_feature_type = EXCLUDED.map_feature_type;

        -- if we got here, everything went OK, so just send back what we were sent
        RETURN upsert_map_feature.geojson;

    END;
$$ LANGUAGE plpgsql VOLATILE;


DROP FUNCTION IF EXISTS search_by_location(DOUBLE PRECISION, DOUBLE PRECISION, TEXT);
CREATE OR REPLACE FUNCTION search_by_location(lng DOUBLE PRECISION, lat DOUBLE PRECISION, address TEXT DEFAULT NULL) RETURNS jsonb AS $$
    DECLARE
        v_jsonb jsonb;
        map_feature_ids uuid[];
        v_label TEXT;
    BEGIN
        map_feature_ids := features_intersecting(lng, lat);

        -- super stupid regex to get the apartment or building number out of a Google Places
        -- search result. In a production system, the "Address2" would already be known so this 
        -- parsing would not be necessary
        IF address IS NOT NULL THEN 
            SELECT replace(substring(search_by_location.address from '#\w+'), '#', '')
            INTO v_label;
        END IF;

        SELECT jsonb_build_object(
            'type', 'FeatureCollection',
            'features', coalesce(jsonb_agg(
                jsonb_build_object(
                    'id', map_feature_id,
                    'type', 'Feature', 
                    'geometry', geojson, 
                    'properties', jsonb_build_object(
                        'id', map_feature_id, 
                        'label', map_feature_label, 
                        'type', map_feature_type,
                        'highlight', CASE WHEN map_feature_label_parts @> (ARRAY[]::TEXT[] || v_label::text) THEN 
                                        jsonb_build_object('search_term', v_label) ELSE NULL END
                    )
                )
            ), '[]'::jsonb)
        )
        INTO v_jsonb
        FROM map_features 
        WHERE map_feature_id = ANY(map_feature_ids);
       
        RETURN v_jsonb;

    END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE;